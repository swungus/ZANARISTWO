<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_enemy1</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>6</depth>
  <persistent>0</persistent>
  <parentName>obj_enemy_parent</parentName>
  <maskName>spr_player_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dodge=false
event_inherited();
attackspeed = 20;//set how many steps before the enemy can attack again
sight = 128;//set how far the enemy can see
range = 64;//set how far the enemy can attack from
spd = 1;//set speed
target = instance_nearest(x,y,par_ally);//set target
wall = obj_wall;//set wall instance
path = path_add();//Init path to find player
hp=8
image_speed = 0;
image_index = 0;
alerted=false
homex=x
homey=y
alarm[3]=60

attackspeed = 20;//set how many steps before the enemy can attack again
sight = 200;//set how far the enemy can see
range = 120;//set how far the enemy can attack from
spd = 1;//set speed
target = par_ally;//set target
wall = obj_solid_parent;//set wall instance
path = path_add();//Init path to find player
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.expr+=2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///do not delete
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

event_inherited();



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
target = instance_nearest(x,y,par_ally);
//look where its going...
dodgethis = instance_nearest(x, y, obj_spell_parent)
image_angle = direction;
i = 0
repeat(instance_number(obj_enemy_parent))
{
  nearestfriend = instance_nth_nearest(x, y, obj_enemy_parent, i)

  if !collision_line(x, y, nearestfriend.x, nearestfriend.y, obj_solid_parent, 1, 1) and distance_to_object(
    nearestfriend) &lt; sight
  {
    if nearestfriend.alerted = true
    {
      alerted = true
    }
  }
  i += 1
}

if distance_to_object(target) &lt; sight &amp;&amp; !collision_line(x, y, target.x, target.y, wall, 1, 1)
{
  alerted = true
}

if alerted = false //if the target is outside of the enemy's line of sight...
  {
    state = 0; //roam

    //the below function is the most accurate method of pathfinding
    //however it becomes quite slow when there are many instances using it
    //and/or when it is used in a very large room
    //also it takes more processing power when there are more cells to check - defined in the obj_enemy_control instance
    //so; try to have a large cell size, few instances using the function and no world-sized rooms, for best efficiency
    if alarm[3] &lt; 0
    if mp_grid_path(global.grid, path, x, y, homex + 10 - random(20), homey + 10 - random(20), 1)
    {
      path_set_kind(path, 1)
      path_set_precision(path, 8)
      var n, x1, y1, x2, y2, x3, y3;
      if path_get_number(path) &gt; 2
      {
        for (n = 1; n &lt; path_get_number(path); n += 1)
        {
          x1 = path_get_point_x(path, n - 1)
          y1 = path_get_point_y(path, n - 1)
          x2 = path_get_point_x(path, n)
          y2 = path_get_point_y(path, n)
          x3 = path_get_point_x(path, n + 1)
          y3 = path_get_point_y(path, n + 1)
          if (x2 - x1) * (y3 - y2) = (x3 - x2) * (y2 - y1)
          {
            path_delete_point(path, n)
            n -= 1
          }
        }
      }

      alarm[3] = random_range(45, 120)
    }
    mp_potential_step_object(path_get_point_x(path, 1), path_get_point_y(path, 1), spd / 3, obj_solid_parent);
    //you'll note that all the enemies use this function to return to their starting positions as its the most effective
    //however, if efficiency becomes a problem with your game, due to the forementioned bottlenecks, use
    //mp_potential_step_object(xgoal,ygoal,speed,wallobject) instead, as demonstrated when the enemies follow the player

  }
else
{
    rdm=10-random(20)
            if distance_to_object(dodgethis) &lt; 30 &amp;&amp; distance_to_object(obj_solid_parent)&gt;10
        {
          if !collision_line(x, y, dodgethis.x, dodgethis.y, obj_solid_parent, 0, 0) //if the bullet can hit this object without being obstructed
            //by cover...
             if mp_grid_path(global.grid, path, x, y, dodgethis.x+rdm, dodgethis.y+rdm, 1)
      {
            mp_potential_step_object(path_get_point_x(path, 1), path_get_point_y(path, 1),- spd / 1.5, obj_solid_parent);
            }
        }


  path_end();
  {
    if distance_to_object(target) &lt; range &amp;&amp; !collision_line(x, y, target.x, target.y, wall, 1, 1) //if the target is within the enemy's range
      {
        path_end();
        speed = 0; //stop moving
        direction = point_direction(x, y, target.x, target.y); //look at the target
        state = 1; //start attacking
      }

    else //move towards the player...
    {
      state = 0; //roam
      if mp_grid_path(global.grid, path, x, y, target.x, target.y, 1)
      {
        path_set_kind(path, 1)
        path_set_precision(path, 8)
        var n, x1, y1, x2, y2, x3, y3;
        if path_get_number(path) &gt; 2
        {
          for (n = 1; n &lt; path_get_number(path); n += 1)
          {
            x1 = path_get_point_x(path, n - 1)
            y1 = path_get_point_y(path, n - 1)
            x2 = path_get_point_x(path, n)
            y2 = path_get_point_y(path, n)
            x3 = path_get_point_x(path, n + 1)
            y3 = path_get_point_y(path, n + 1)
            if (x2 - x1) * (y3 - y2) = (x3 - x2) * (y2 - y1)
            {
              path_delete_point(path, n)
              n -= 1
            }
          }
        }

        mp_potential_step_object(path_get_point_x(path, 1), path_get_point_y(path, 1), spd,
          obj_solid_parent);

      }
    }

  }

}
if alarm[4] &lt; 0
dodge = false
if state = 1 //if attacking
  {
    if alarm[0] &lt; 0
    {
      //Bullet Variables
      var blt = instance_create(x + lengthdir_x(16, direction), y + lengthdir_y(16, direction),
        obj_enemy1_spell);
      blt.speed = 4;
      //make bullet aim at target...
      blt.direction = direction - 3 + random(6);
      blt.image_angle = blt.direction;
      alarm[0] = attackspeed - 3 + random(6); //reset timer for attacking
    }
  }
if hp &lt;= 0
{
  instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy_parent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (other.x &lt; x) //if other enemy is to the left
{
    x += 1;//move right
}
if (other.x &gt; x)//if other enemy is to the right
{
    x -=1;//move left
}
if (other.y &lt; y) //if other enemy is above
{
    y +=1; //move down
}
if (other.y &gt; y) //if other enemy is below
{
    y -=1; //move up
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
///debug
draw_self();
if global.debug = true
{
    draw_set_color(c_black);
    draw_set_halign(fa_center);
    //steering...
    draw_text(x,y-28,string(steering));
    draw_set_halign(fa_left);
    //wall check...
    draw_line(x+lengthdir_x(check1width,image_angle+90),y+lengthdir_y(check1width,image_angle+90),x+lengthdir_x(checkdistance,image_angle+check2width),y+lengthdir_y(checkdistance,image_angle+check2width));
    draw_line(x,y,x+lengthdir_x(checkdistance,image_angle),y+lengthdir_y(checkdistance,image_angle));
    draw_line(x+lengthdir_x(check1width,image_angle-90),y+lengthdir_y(check1width,image_angle-90),x+lengthdir_x(checkdistance,image_angle-check2width),y+lengthdir_y(checkdistance,image_angle-check2width));
    if !collision_line(x,y,target.x,target.y,wall,1,1)
    {draw_set_color(c_lime);}
    else
    {draw_set_color(c_red);}
    draw_line(x,y,target.x,target.y);//LOS
    if distance_to_object(target) &gt; sight
    {draw_set_color(c_red);}
    else
    {draw_set_color(c_lime);}
    draw_circle(x,y,sight+20,1);//sight
    if distance_to_object(target) &gt; range
    {draw_set_color(c_red);}
    else
    {draw_set_color(c_lime);}
    draw_circle(x,y,range+24,1);//range
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
